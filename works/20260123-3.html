<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Modern Art with Speed Knob</title>
<style>
html,body{
  margin:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#0b0c10;
}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const rand = (a,b)=>Math.random()*(b-a)+a;
const pick = arr => arr[Math.floor(Math.random()*arr.length)];

function randomColor(){
  return `hsla(${rand(0,360)},${rand(60,100)}%,${rand(40,80)}%,${rand(0.1,0.5)})`;
}

// ===== ノブ =====
let speed = 1; // 描画速度倍率
const knob = {
  x: () => canvas.width-60,
  y: () => canvas.height/2,
  r: 20,
  dragging:false,
  min:0,   // 完全停止
  max:1    // 最大描画速度（500個/フレーム相当）
};

// ===== メインループ描画 =====
function drawArt(){
  // 背景を透過で残す
  ctx.fillStyle = "rgba(11,12,16,0.1)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const drawCount = Math.floor(500*speed); // ノブで描画量を調整
  for(let i=0;i<drawCount;i++){
    const x = rand(0,canvas.width);
    const y = rand(0,canvas.height);
    const r = rand(10,100);
    const angle = rand(0,Math.PI*2);
    const col = randomColor();

    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);
    ctx.shadowColor = "rgba(255,255,255,0.3)";
    ctx.shadowBlur = rand(5,20);

    ctx.beginPath();
    const shapeType = pick(["circle","triangle","square","line","arc"]);
    switch(shapeType){
      case "circle":
        ctx.arc(0,0,r,0,Math.PI*2);
        ctx.fillStyle = col; ctx.fill();
        break;
      case "triangle":
        ctx.moveTo(0,-r); ctx.lineTo(r, r); ctx.lineTo(-r, r); ctx.closePath();
        ctx.fillStyle = col; ctx.fill();
        break;
      case "square":
        ctx.fillStyle = col; ctx.fillRect(-r,-r,r*2,r*2); break;
      case "line":
        ctx.strokeStyle = col; ctx.lineWidth = rand(1,5);
        ctx.moveTo(-r,-r); ctx.lineTo(r,r); ctx.stroke(); break;
      case "arc":
        ctx.strokeStyle = col; ctx.lineWidth = rand(1,4);
        ctx.arc(0,0,r,rand(0,Math.PI*2),rand(0,Math.PI*2)); ctx.stroke();
        break;
    }
    ctx.restore();
  }
}

// ===== ノブ描画 =====
function drawKnob(){
  const x = knob.x();
  const y = knob.y();
  const h = 200;

  // 線メモリ
  ctx.strokeStyle="rgba(255,255,255,0.2)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x,y-h/2); ctx.lineTo(x,y+h/2); ctx.stroke();

  // メモリ
  for(let v=0;v<=1;v+=0.1){
    const t = v;
    const yy = y+h/2 - t*h;
    ctx.beginPath();
    ctx.lineWidth = (v===1)?2:1;
    ctx.moveTo(x-12,yy); ctx.lineTo(x+12,yy); ctx.stroke();
  }

  // 現在値の丸
  const t = (speed-knob.min)/(knob.max-knob.min);
  const ky = y+h/2 - t*h;
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(x,ky,knob.r,0,Math.PI*2);
  ctx.fill();
}

// ===== マウス操作 =====
canvas.addEventListener("mousedown", e=>{
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX-r.left;
  const my = e.clientY-r.top;
  const x = knob.x(), y = knob.y(), h=200;
  if(mx>x-knob.r*2 && mx<x+knob.r*2 && my>y-h/2-knob.r && my<y+h/2+knob.r){
    knob.dragging=true;
  }
});
window.addEventListener("mouseup", ()=>knob.dragging=false);
window.addEventListener("mousemove", e=>{
  if(!knob.dragging) return;
  const r = canvas.getBoundingClientRect();
  const my = Math.max(knob.y()-100+knob.r, Math.min(knob.y()+100-knob.r, e.clientY-r.top));
  const h = 200-knob.r*2;
  speed = knob.max - ((my-(knob.y()-100+knob.r))/h)*(knob.max-knob.min);
  if(speed<0) speed=0;
  if(speed>knob.max) speed=knob.max;
});

// ===== メインループ =====
function loop(){
  drawArt();
  drawKnob();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
