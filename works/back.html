<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>3D Back Buttons Non-Overlapping</title>
<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#111;
  font-family:sans-serif;
  height:100%;
}
canvas{display:block;}
#ui{
  position:fixed;
  top:30px;
  width:100%;
  text-align:center;
  color:white;
  pointer-events:none;
}
#ui h1{
  margin:0;
  font-size:42px;
  letter-spacing:2px;
}
#ui p{
  margin:8px 0 0;
  font-size:18px;
  opacity:0.8;
}
</style>
</head>
<body>

<div id="ui">
  <h1>戻る / Back</h1>
  <p>どれか押すと戻ります</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

let camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 3, 15);
camera.lookAt(0,0,0);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
document.body.appendChild(renderer.domElement);

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff,0.5));
let light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,10);
scene.add(light);

/* Button Creator */
function createRealButton(type, scale){
  const group = new THREE.Group();
  const baseMat = new THREE.MeshStandardMaterial({color:0x888888, metalness:0.6, roughness:0.3});
  const topMat = new THREE.MeshStandardMaterial({color:0xcc0000, metalness:0.2, roughness:0.4});

  // Base
  let base = new THREE.Mesh(new THREE.CylinderGeometry(2.2*scale, 2.2*scale, 0.6*scale, 32), baseMat);
  group.add(base);

  // Top
  let top;
  if(type==="round"){
    top = new THREE.Mesh(new THREE.CylinderGeometry(1.6*scale, 1.6*scale, 0.8*scale,32), topMat);
  }
  if(type==="square"){
    top = new THREE.Mesh(new THREE.BoxGeometry(3*scale,1*scale,3*scale), topMat);
  }
  if(type==="arcade"){
    top = new THREE.Mesh(new THREE.SphereGeometry(1.5*scale,32,32,0,Math.PI*2,0,Math.PI/2), topMat);
  }
  top.position.y = 0.7*scale;
  group.add(top);

  group.userData = { pressed:false, top:top, velocity:0, scale:scale };
  scene.add(group);
  return group;
}

/* Generate non-overlapping buttons on a grid */
let buttons = [];
let types = ["round","square","arcade"];
let gridX = 6; // 横方向の候補数
let gridZ = 4; // 奥行き方向の候補数
let occupied = [];

for(let i=0;i<7;i++){
  let type = types[i % types.length];
  let scale = 0.7 + Math.random()*0.6; // 0.7～1.3のサイズ差

  let pos;
  let attempts = 0;
  do{
    let gx = Math.floor(Math.random()*gridX) - gridX/2;
    let gz = Math.floor(Math.random()*gridZ) - gridZ/2;
    pos = [gx*4, gz*3]; // 画面内に収まるよう間隔
    attempts++;
  }while(occupied.some(p=>Math.hypot(p[0]-pos[0],p[1]-pos[1])<4) && attempts<100);
  occupied.push(pos);

  let btn = createRealButton(type, scale);
  btn.position.set(pos[0], 0, pos[1]);
  buttons.push(btn);
}

/* Animation */
function animate(){
  requestAnimationFrame(animate);
  buttons.forEach(b=>{
    if(b.userData.pressed){
      b.userData.velocity += 0.02;
      b.userData.top.position.y -= b.userData.velocity;
      if(b.userData.top.position.y < 0.2){
        setTimeout(()=>window.location.href="index.html",150);
      }
    }
  });
  renderer.render(scene,camera);
}
animate();

/* Interaction */
let ray = new THREE.Raycaster();
let mouse = new THREE.Vector2();

function onPointerDown(e){
  if(e.touches){
    mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 -1;
    mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 +1;
  } else {
    mouse.x = (e.clientX / window.innerWidth) * 2 -1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 +1;
  }
  ray.setFromCamera(mouse,camera);
  let hits = ray.intersectObjects(scene.children,true);
  if(hits.length){
    let obj = hits[0].object;
    buttons.forEach(b=>{
      if(obj === b.userData.top){
        b.userData.pressed = true;
        if(navigator.vibrate) navigator.vibrate(15);
      }
    });
  }
}

renderer.domElement.addEventListener("pointerdown", onPointerDown);
renderer.domElement.addEventListener("touchstart", onPointerDown);

/* Resize */
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>

