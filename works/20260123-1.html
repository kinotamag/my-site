<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
  margin: 0;
  background: white;
  overflow: hidden;

  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

* {
  -webkit-user-drag: none;
  touch-action: none;
}

canvas {
  display: block;
  position: fixed;
  top: 0;
  left: 0;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let mouse = {x: canvas.width / 2, y: canvas.height / 2};
let pen = {x: mouse.x, y: mouse.y};
let lastPen = {x: pen.x, y: pen.y};

const easePC = 0.22;
const easeSP = 0.3;
const maxWidth = 25;
const minWidth = 0.5;
let width = maxWidth;

let points = [];
let drawCount = 0;
const maxDraw = 450;

function interpolate(p0, p1, steps){
  const arr = [];
  for(let i = 1; i <= steps; i++){
    const t = i / steps;
    arr.push({
      x: p0.x + (p1.x - p0.x) * t,
      y: p0.y + (p1.y - p0.y) * t
    });
  }
  return arr;
}

// PCマウス
window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

// スマホタッチ（1本指）
window.addEventListener("touchstart", e => {
  if(e.touches.length === 1){
    mouse.x = e.touches[0].clientX;
    mouse.y = e.touches[0].clientY;
  }
}, {passive:false});

window.addEventListener("touchmove", e => {
  if(e.touches.length === 1){
    e.preventDefault();
    mouse.x = e.touches[0].clientX;
    mouse.y = e.touches[0].clientY;
  }
}, {passive:false});

function draw(){
  const isSP = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const ease = isSP ? easeSP : easePC;

  pen.x += (mouse.x - pen.x) * ease;
  pen.y += (mouse.y - pen.y) * ease;

  const dx = pen.x - lastPen.x;
  const dy = pen.y - lastPen.y;
  const speed = Math.sqrt(dx*dx + dy*dy);

  let targetWidth = maxWidth - Math.pow(speed*1.3, 0.85);
  if(targetWidth < minWidth) targetWidth = minWidth;
  width += (targetWidth - width) * 0.2;

  points.push({x: pen.x, y: pen.y, w: width});
  if(points.length > 20) points.shift();

  if(points.length >= 2){
    for(let i=0;i<points.length-1;i++){
      const p0 = points[i];
      const p1 = points[i+1];
      const steps = isSP ? Math.max(1, Math.floor(speed/2)) : 1;
      const interpPoints = interpolate(p0, p1, steps);

      interpPoints.forEach(pt => {
        ctx.beginPath();
        ctx.moveTo(lastPen.x, lastPen.y);
        ctx.lineTo(pt.x, pt.y);
        const w = p1.w * (1 - i/points.length * 0.6);
        ctx.lineWidth = w;
        const shade = Math.floor(Math.random() * (isSP ? 10 : 20));
        ctx.strokeStyle = `rgb(${shade},${shade},${shade})`;
        ctx.lineCap = "round";
        ctx.stroke();
        lastPen.x = pt.x;
        lastPen.y = pt.y;
        drawCount++;
      });
    }
  }

  if(drawCount > maxDraw){
    ctx.fillStyle = "rgba(255,255,255,0.008)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
