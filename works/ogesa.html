<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,body{margin:0;background:black;overflow:hidden;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<script>
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
resize();
addEventListener("resize",resize);

const vert = `
attribute vec2 position;
void main(){
  gl_Position = vec4(position,0.0,1.0);
}
`;

const frag = `
precision highp float;

uniform vec2 resolution;
uniform vec2 rotation;

#define PI 3.14159265359

float grooveSpacing = 1.6e-6;

vec3 wavelengthToRGB(float wl){
    float r=0.0,g=0.0,b=0.0;
    if(wl>=380.0 && wl<440.0){ r=-(wl-440.0)/(440.0-380.0); b=1.0; }
    else if(wl<490.0){ g=(wl-440.0)/(490.0-440.0); b=1.0; }
    else if(wl<510.0){ g=1.0; b=-(wl-510.0)/(510.0-490.0); }
    else if(wl<580.0){ r=(wl-510.0)/(580.0-510.0); g=1.0; }
    else if(wl<645.0){ r=1.0; g=-(wl-645.0)/(645.0-580.0); }
    else if(wl<=780.0){ r=1.0; }
    return vec3(r,g,b);
}

mat3 rotX(float a){
  return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));
}
mat3 rotY(float a){
  return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));
}

void main(){

    vec2 uv = (gl_FragCoord.xy/resolution.xy)*2.0-1.0;
    uv.x *= resolution.x/resolution.y;

    vec3 camPos = vec3(0.0,0.0,2.5);
    vec3 rayDir = normalize(vec3(uv,-1.5));

    mat3 rot = rotY(rotation.x) * rotX(rotation.y);

    vec3 center = vec3(0.0,0.0,0.0);
    float outer = 0.6;
    float inner = 0.15;
    float thickness = 0.04;

    // --- 円柱との交差 ---
    vec3 oc = camPos - center;
    vec3 n = rot * vec3(0.0,0.0,1.0);

    float denom = dot(rayDir, n);
    float t = dot(center - camPos, n)/denom;

    if(t<0.0){
        gl_FragColor = vec4(0.0); return;
    }

    vec3 hit = camPos + rayDir*t;
    vec3 local = rot*(hit-center);

    float r = length(local.xy);

    if(r<inner || r>outer){
        gl_FragColor = vec4(0.0); return;
    }

    // 表面法線
    vec3 normal = normalize(n);

    vec3 lightDir = normalize(vec3(0.5,0.6,1.0));

    float sin_i = length(cross(normal, lightDir));
    float sin_r = length(cross(normal, -rayDir));

    vec3 color = vec3(0.0);

    // 高密度スペクトル積分
    for(float wl=380.0; wl<=780.0; wl+=5.0){
        float lambda = wl*1e-9;
        float phase = grooveSpacing*(sin_i+sin_r)/lambda;

        float peak = fract(phase);
        float intensity = exp(-pow(peak-0.5,2.0)/0.01);

        color += wavelengthToRGB(wl)*intensity;
    }

    color /= 80.0;

    // 強めの鏡面反射
    float spec = pow(max(dot(normal,lightDir),0.0),120.0);
    color += spec;

    // 環境ライト
    color += vec3(0.05);

    // トーンマッピング
    color = color / (color + vec3(1.0));

    // ガンマ補正
    color = pow(color, vec3(1.0/2.2));

    gl_FragColor = vec4(color,1.0);
}
`;

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  return s;
}

const program = gl.createProgram();
gl.attachShader(program,compile(gl.VERTEX_SHADER,vert));
gl.attachShader(program,compile(gl.FRAGMENT_SHADER,frag));
gl.linkProgram(program);
gl.useProgram(program);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
 -1,-1,1,-1,-1,1,
 -1,1,1,-1,1,1
]),gl.STATIC_DRAW);

const pos = gl.getAttribLocation(program,"position");
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);

const resLoc = gl.getUniformLocation(program,"resolution");
const rotLoc = gl.getUniformLocation(program,"rotation");

let rotation=[0,0];

addEventListener("mousemove",e=>{
  rotation[0]=(e.clientX/innerWidth-0.5)*2.0;
  rotation[1]=(e.clientY/innerHeight-0.5)*2.0;
});

function render(){
  gl.uniform2f(resLoc,canvas.width,canvas.height);
  gl.uniform2f(rotLoc,rotation[0],rotation[1]);
  gl.drawArrays(gl.TRIANGLES,0,6);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
