<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Interactive CD Art</title>
<style>
html,body{
  margin:0;
  background:#111;
  overflow:hidden;
  touch-action:none;
}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize",resize);

const TAU = Math.PI*2;

// CD rotation
let rotX=0, rotY=0;
let targetX=0, targetY=0;
let vx=0, vy=0;
canvas.addEventListener("pointermove", e=>{
  targetY = (e.clientX/canvas.width-0.5)*2.0;
  targetX = (e.clientY/canvas.height-0.5)*2.0;
});

// Wavelength to RGB
function wavelengthToRGB(wl){
  let R=0,G=0,B=0;
  if(wl>=380 && wl<440){ R=-(wl-440)/60; B=1; }
  else if(wl<490){ G=(wl-440)/50; B=1; }
  else if(wl<510){ G=1; B=-(wl-510)/20; }
  else if(wl<580){ R=(wl-510)/70; G=1; }
  else if(wl<645){ R=1; G=-(wl-645)/65; }
  else if(wl<=780){ R=1; }
  return [R*255,G*255,B*255];
}

function rotate(p,xRot,yRot){
  let [x,y,z]=p;
  let cx=Math.cos(xRot), sx=Math.sin(xRot);
  let cy=Math.cos(yRot), sy=Math.sin(yRot);
  let dy=y*cx - z*sx;
  let dz=y*sx + z*cx;
  y=dy; z=dz;
  let dx=x*cy + z*sy;
  dz=-x*sy + z*cy;
  x=dx; z=dz;
  return [x,y,z];
}

function project(p){
  const f=600;
  const scale=f/(f+p[2]+1);
  return [p[0]*scale, p[1]*scale];
}

// Particle class for interactive points
class Particle{
  constructor(x,y){
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.selected = false;
    this.baseSize = 2 + Math.random()*2;
    this.hueOffset = Math.random()*360;
  }
  update(){
    if(!this.selected){
      this.vx *= 0.95; this.vy *= 0.95;
      this.x += this.vx; this.y += this.vy;
      // small random movement
      this.x += (Math.random()-0.5)*0.5;
      this.y += (Math.random()-0.5)*0.5;
    }
  }
  draw(){
    let hue = (this.hueOffset + rotX*50 + this.y*0.2)%360;
    let size = this.baseSize + Math.sin(Date.now()*0.005 + this.x*0.01)*1.2;
    ctx.beginPath();
    ctx.arc(this.x,this.y,size,0,TAU);
    ctx.fillStyle = `hsl(${hue},80%,60%)`;
    ctx.fill();
  }
}

const particles = [];
const particleCount = 80;
for(let i=0;i<particleCount;i++){
  particles.push(new Particle(Math.random()*canvas.width, Math.random()*canvas.height));
}

let selectedParticles = null;
let offsetX=0, offsetY=0;

canvas.addEventListener('pointerdown', e=>{
  for(let p of particles){
    if(Math.hypot(e.clientX-p.x,e.clientY-p.y)<15){
      selectedParticles = particles.filter(q=>Math.hypot(p.x-q.x,p.y-q.y)<50);
      offsetX = e.clientX; offsetY = e.clientY;
      for(let q of selectedParticles) q.selected = true;
      break;
    }
  }
});

canvas.addEventListener('pointermove', e=>{
  if(selectedParticles){
    let dx = e.clientX - offsetX;
    let dy = e.clientY - offsetY;
    for(let p of selectedParticles){
      p.x += dx; p.y += dy;
      // ripple effect on CD
      rippleOffset = dx*0.1;
    }
    offsetX = e.clientX; offsetY = e.clientY;
  }
});

canvas.addEventListener('pointerup', e=>{
  if(selectedParticles){
    for(let p of selectedParticles) p.selected = false;
    selectedParticles = null;
  }
});

// ripple effect variable
let rippleOffset = 0;

function render(){
  vx+=(targetX-rotX)*0.04;
  vy+=(targetY-rotY)*0.04;
  vx*=0.9; vy*=0.9;
  rotX+=vx; rotY+=vy;

  // dynamic background
  let grad = ctx.createRadialGradient(canvas.width/2,canvas.height/2,0,canvas.width/2,canvas.height/2,Math.max(canvas.width,canvas.height)/2);
  grad.addColorStop(0,'#111');
  grad.addColorStop(1,'#000022');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const cx = canvas.width/2;
  const cy = canvas.height/2;

  // Draw CDs
  const cdCount = 3;
  const RBase = Math.min(canvas.width,canvas.height)*0.18;
  const spacing = RBase*1.5;
  const steps = 180;
  for(let n=0;n<cdCount;n++){
    let R = RBase;
    let inner = R*0.3;
    let thickness = R*0.05;
    let offsetXcd = (n-(cdCount-1)/2)*spacing;
    let offsetYcd = 0;

    for(let i=0;i<steps;i++){
      const a = i/steps*TAU;
      for(let r=inner;r<R;r+=1.5){
        let x = r*Math.cos(a);
        let y = r*Math.sin(a);
        let z = 0;
        let p = rotate([x,y,z], rotX+0.2*n, rotY+0.15*n);
        let proj = project(p);
        let sx = cx + proj[0] + offsetXcd;
        let sy = cy + proj[1] + offsetYcd;

        // groove & lighting
        let groove=[Math.cos(a),Math.sin(a),0];
        groove=rotate(groove, rotX+0.2*n, rotY+0.15*n);
        let light=[0.5,-0.3,1];
        let ln = Math.hypot(...light);
        light = light.map(v=>v/ln);
        let dot = groove[0]*light[0]+groove[1]*light[1]+groove[2]*light[2];
        dot = 0.2 + 0.8*Math.max(dot,0);
        let nm = 420+300*(dot*0.5+0.5 + rippleOffset*0.3);
        if(nm>380 && nm<780){
          let [Rcol,Gcol,Bcol] = wavelengthToRGB(nm);
          let intensity = 0.3 + Math.pow(dot,5)*1.8;
          let factor = 1.2 + dot*1.5;
          ctx.fillStyle=`rgb(${Math.min(Rcol*intensity*factor,255)},${Math.min(Gcol*intensity*factor,255)},${Math.min(Bcol*intensity*factor,255)})`;
          ctx.fillRect(sx,sy,1.5,1.5);
        }
      }
    }

    // Side ring
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const a = i/steps*TAU;
      let x = R*Math.cos(a);
      let y = R*Math.sin(a);
      let z = thickness;
      let p = project(rotate([x,y,z], rotX+0.2*n, rotY+0.15*n));
      ctx.lineTo(cx+p[0]+offsetXcd, cy+p[1]+offsetYcd);
    }
    ctx.closePath();
    ctx.strokeStyle="rgba(255,255,255,0.35)";
    ctx.stroke();
  }

  // Update and draw interactive particles
  for(let p of particles) p.update();

  // Draw lines between close particles
  for(let i=0;i<particles.length;i++){
    for(let j=i+1;j<particles.length;j++){
      let pi = particles[i];
      let pj = particles[j];
      let d = Math.hypot(pi.x-pj.x, pi.y-pj.y);
      if(d<80){
        ctx.beginPath();
        ctx.moveTo(pi.x, pi.y);
        ctx.lineTo(pj.x, pj.y);
        ctx.strokeStyle = `hsla(${(pi.hueOffset+rotX*50)%360},80%,70%,${1-d/80})`;
        ctx.lineWidth = 1 + (80-d)/50;
        ctx.stroke();
      }
    }
  }

  for(let p of particles) p.draw();

  // slowly decay ripple
  rippleOffset *= 0.92;

  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
