<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ぷにぷにスライム＋垂直飛び出し＋安定初期</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#111;height:100%;}
canvas{display:block;width:100%;height:100%;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
<script>
const canvas=document.getElementById('c');
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111111);

const camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,100);
camera.position.set(0,0,8);
camera.lookAt(0,0,0);

const renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:true});
renderer.setSize(window.innerWidth,window.innerHeight);

// スライム球（初期形状安定・少し大きめ）
const SEG=128;
const geo=new THREE.SphereGeometry(1.5,SEG,SEG);
const mat=new THREE.MeshStandardMaterial({
    color:0x8070ff,
    roughness:0.35,
    metalness:0.25,
    transparent:true,
    opacity:0.85,
    side:THREE.DoubleSide
});
const slime=new THREE.Mesh(geo,mat);
scene.add(slime);

// ライト
const light=new THREE.DirectionalLight(0xffffff,1.5);
light.position.set(10,15,10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x666666));

// 元頂点
const original=geo.attributes.position.array.slice();

// マウス・タッチ座標
let mouse=new THREE.Vector2(0,0);
function setMouse(e){
    if(e.touches){
        mouse.x=(e.touches[0].clientX/window.innerWidth)*2-1;
        mouse.y=-(e.touches[0].clientY/window.innerHeight)*2+1;
    }else{
        mouse.x=(e.clientX/window.innerWidth)*2-1;
        mouse.y=-(e.clientY/window.innerHeight)*2+1;
    }
}
window.addEventListener('pointermove',setMouse);
window.addEventListener('touchmove',setMouse);

const ray=new THREE.Raycaster();

// 頂点変形用
const velocities=new Float32Array(original.length);
const influenceRadius=2.0;
const pushStrength=0.18;
const returnSpeed=0.06; // 初期安定のため少し強め
const inertia=0.06;

// 視点操作
let isDown=false,lastX=0,lastY=0;
canvas.addEventListener('pointerdown', e=>{isDown=true; lastX=e.clientX; lastY=e.clientY;});
canvas.addEventListener('pointerup', ()=>{isDown=false;});
canvas.addEventListener('pointermove', e=>{
    if(isDown){
        const dx=(e.clientX-lastX)*0.005;
        const dy=(e.clientY-lastY)*0.005;
        camera.position.applyAxisAngle(new THREE.Vector3(0,1,0),-dx);
        camera.position.applyAxisAngle(new THREE.Vector3(1,0,0),-dy);
        camera.lookAt(0,0,0);
        lastX=e.clientX; lastY=e.clientY;
    }
});
canvas.addEventListener('touchstart', e=>{isDown=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;});
canvas.addEventListener('touchend', ()=>{isDown=false;});
canvas.addEventListener('touchmove', e=>{
    if(isDown){
        const dx=(e.touches[0].clientX-lastX)*0.005;
        const dy=(e.touches[0].clientY-lastY)*0.005;
        camera.position.applyAxisAngle(new THREE.Vector3(0,1,0),-dx);
        camera.position.applyAxisAngle(new THREE.Vector3(1,0,0),-dy);
        camera.lookAt(0,0,0);
        lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
    }
});

// ぷにぷに変形＋垂直強調＋初期形状維持
function animate(){
    requestAnimationFrame(animate);

    ray.setFromCamera(mouse,camera);
    const intersects=ray.intersectObject(slime);
    const pos=geo.attributes.position.array;
    for(let i=0;i<pos.length;i+=3){
        let vx=velocities[i],vy=velocities[i+1],vz=velocities[i+2];
        let dx=original[i]-pos[i],dy=original[i+1]-pos[i+1],dz=original[i+2]-pos[i+2];
        // 形状を強く戻す
        vx+=dx*returnSpeed; vy+=dy*returnSpeed; vz+=dz*returnSpeed;

        if(intersects.length>0){
            const p=intersects[0].point;
            let ddx=pos[i]-p.x,dyy=pos[i+1]-p.y,ddz=pos[i+2]-p.z;
            let d=Math.sqrt(ddx*ddx+dyy*dyy+ddz*ddz);
            if(d<influenceRadius){
                let f=(influenceRadius-d)/influenceRadius*pushStrength;
                vx+=ddx/d*f;
                vy+=dyy/d*f*1.8; // 垂直飛び出し強調
                vz+=ddz/d*f;
            }
        }

        vx*=(1-inertia); vy*=(1-inertia); vz*=(1-inertia);
        velocities[i]=vx; velocities[i+1]=vy; velocities[i+2]=vz;
        pos[i]+=vx; pos[i+1]+=vy; pos[i+2]+=vz;
    }

    geo.attributes.position.needsUpdate=true;
    geo.computeVertexNormals();

    slime.rotation.y+=0.002;
    slime.position.y=0.15*Math.sin(Date.now()*0.003); // ゆらゆら垂直飛び出し

    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
